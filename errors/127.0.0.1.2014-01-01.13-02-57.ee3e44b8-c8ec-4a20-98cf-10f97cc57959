(dp1
S'output'
p2
S"<type 'exceptions.TypeError'> long() argument must be a string or a number, not 'Table'"
p3
sS'layer'
p4
S'/Users/adin/Work/SIRI/TimeClock/siri/applications/siriadmin/controllers/timeclock.py'
p5
sS'code'
p6
S'########## Some Global Variables ##############\r\n"""\r\nWe need to find the current pay period\r\n"""\r\nFIRST_PERIOD_START = datetime(2013, 11, 10) # TODO: Get this set to the beginning of a pay period ############################\r\nPERIOD_START = FIRST_PERIOD_START           # TODO: implement tzinfo to make datetimes aware ############################\r\nPAY_PERIOD = timedelta(weeks = 2) - timedelta(microseconds=1)\r\nPERIOD_END = PERIOD_START + PAY_PERIOD\r\nNOW = datetime.now()\r\nwhile not (PERIOD_START <= NOW < PERIOD_END):\r\n    PERIOD_START += timedelta(weeks = 2)\r\n    PERIOD_END = PERIOD_START + PAY_PERIOD\r\n\r\ndef index():\r\n    redirect(URL(employeedash))\r\n\r\n@auth.requires_login()\r\ndef employeedash():\r\n    """\r\n    this will become the index page\r\n    TODO: create a clockin clockout feature ######################################################################\r\n    """\r\n    fields = [\'project\',\'work_date\',\'time_in\',\'time_in_ampm\',\'time_out\',\'time_out_ampm\',\'description\']\r\n    form = SQLFORM(db.timeclock, submit_button=\'Submit Hours\', fields=fields)\r\n    if form.process(onvalidation=calcHours).accepted:\r\n        response.flash = \'Thank you for submitting your time \' + str(form.vars.hours)\r\n    elif form.errors:\r\n        response.flash = \'There was an error on the form\'\r\n    response.title = session.auth.user.first_name + "\'s Dashboard"\r\n    response.subtitle = \'Current pay period is \' + PERIOD_START.strftime("%m/%d/%Y") + \' - \' + PERIOD_END.strftime("%m/%d/%Y")\r\n\r\n    query = (db.timeclock.usr_id == session.auth.user.id)&(db.timeclock.work_date > PERIOD_START)&(db.timeclock.work_date < PERIOD_END)\r\n    clockEntries = db(query).select(db.timeclock.ALL, orderby=~db.timeclock.work_date)\r\n    sum = db.timeclock.hours.sum()\r\n    totalHours = db(query).select(sum).first()[sum] or 0\r\n\r\n    return locals() #dict(form=form, clockEntries=clockEntries, totalHours=totalHours)\r\n\r\n@auth.requires_signature()\r\ndef ask():\r\n    form=SQLFORM.factory(\r\n        Field(\'message\', \'text\', requires=IS_NOT_EMPTY()))\r\n    if form.process().accepted:\r\n        if mail.send(to=\'e.caldwell@sirinstitute.org\',\r\n                  subject=\'from %s\' % session.auth.user.email,\r\n                  message = form.vars.message):\r\n            response.flash = \'Thank you\'\r\n            response.js = "jQuery(\'#%s\').hide()" % request.cid\r\n        else:\r\n            form.errors.your_email = "Unable to send the email"\r\n    return form\r\n\r\n@auth.requires_login()\r\ndef addtime():\r\n    """\r\n    Allows a logged in user to add an entry for time worked\r\n    """\r\n    form = SQLFORM(db.timeclock)\r\n    if form.process().accepted:\r\n        response.flash = \'Thank you for submitting your time\'\r\n    elif form.errors:\r\n        response.flash = \'There was an error on the form\'\r\n    else:\r\n        response.flash = \'Welcome \' + session.auth.user.first_name + \' your id is: \' + str(session.auth.user.id)\r\n    response.title = \'New Entry\'\r\n    response.subtitle = \'please fill out the form below\'\r\n    hoursTest = type(db.timeclock.time_in)\r\n    return dict(form=form, hoursTest=hoursTest)\r\n\r\ndef clockIn():\r\n    session.clockIn = datetime.today()\r\n    message = \'You successfully clocked in at: {:%H:%M}\'.format(session.clockIn)\r\n    return message\r\n\r\n@auth.requires_signature()\r\ndef clock_out_modal():\r\n    message = None\r\n    form=SQLFORM.factory(\r\n        Field(\'project\', \'string\', requires=IS_IN_DB(db,\'siri_projects.name\')),\r\n        Field(\'description\', \'text\', requires=IS_NOT_EMPTY()))\r\n    if form.process().accepted:\r\n        message = clockOut(form.vars.project, form.vars.description)\r\n    return dict(form=form, message=message)\r\n\r\ndef clockOut(project, description):\r\n    session.clockOut = datetime.today()\r\n    hours = session.clockOut - session.clockIn\r\n    timeInAmPm = None\r\n    timeOutAmPm = None\r\n    usrId = session.auth.user.id\r\n    \'\'\'TODO: insert the new record into the DB.\r\n             how do they choose the project and enter description? pop up a modal - clock_out_modal?\r\n             what if the session ends before clock out? send a notifiction for next login?\r\n             convert timeIn/Out and ampm from 24 hour time\'\'\'\r\n    entryId = db.timeclock.insert({\'project\':project, \r\n                                   \'work_date\':datetime.today(), \r\n                                   \'time_in\':session.clockIn,\r\n                                   \'time_in_ampm\':timeInAmPm, \r\n                                   \'time_out\':session.clockIn,\r\n                                   \'time_out_ampm\':timeInAmPm,\r\n                                   \'description\':description,\r\n                                   \'hours\':hours,\r\n                                   \'usr_id\':usrId})\r\n    message = \'You successfully clocked out at {0:%H:%M} for a total time of {1} {2} and {1} {3}.\'.format(session.clockOut, hours, "hours", "minutes")\r\n    return message\r\n\r\n@auth.requires_login()\r\ndef displaytime():\r\n    """\r\n    Shows the entries for the user that is logged in\r\n    TODO: fix the modal comment/question submit error  ################################\r\n    """\r\n    payPeriods = 0\t\r\n    query = db.timeclock.usr_id == session.auth.user.id\r\n    grid = SQLFORM.grid(query, deletable=False, editable=False, create=False, orderby=~db.timeclock.work_date)\r\n\r\n    return dict(grid=grid)\r\n\r\n@auth.requires_login()\r\ndef bulletin_board():\r\n    """\r\n    Shows the bulletin board and the form to submit a new comment\r\n    Includes pagination.\r\n    """\r\n    if len(request.args):\r\n        page=int(request.args[0])\r\n    else:\r\n        page = 0\r\n    items_per_page=5\r\n    limitby=(page * items_per_page, (page + 1) * items_per_page + 1)\r\n    comments=db(db.bulletin_post).select(limitby=limitby, orderby=~db.bulletin_post.created_on)\r\n\r\n    form=SQLFORM(db.bulletin_post).process(next=URL(args=[0]))\r\n    return locals()\r\n\r\ndef trello():\r\n    """\r\n    Will eventuall show trellow information\r\n    """\r\n    APIKEY = "dfa1c6f431ffce07a6cd11a9daa0d081"\r\n    APISECRET = "fb89378fdb1f65d8c2b03af9ee3314b76e92fc33cceca6a76a03964da07a8f69"\r\n    requestURL = "https://trello.com/1/authorize?key=%s&name=%s&expiration=30days&response_type=token" % (APIKEY, "SIRI+")\r\n    expired = "token expired"\r\n    QUERY = db.trello_auth.usr_id == session.auth.user.id\r\n\r\n    token = getBoardsURL = page = notifications = unreadNotifications = ""\r\n    # check to see if we have a token on file. It is used to determine how the page is displayed\r\n    authTable = db(QUERY).select(db.trello_auth.token)\r\n    if authTable:\r\n        # Because it is possible for permission to be revoked we need to be able to check to a bad load.\r\n        token = authTable[0].token\r\n        if token != expired:\r\n            try:\r\n                getBoardsURL = "https://trello.com/1/members/my/notifications/?key=%s&token=%s&read_filter=unread&fields=data,unread" % (APIKEY, token)\r\n                page = urllib2.urlopen(getBoardsURL).read() #fetch(getBoardsURL)\r\n                notifications = json.loads(page.decode(\'utf8\'))\r\n                unreadNotifications = len(notifications)\r\n            except urllib2.HTTPError as e:\r\n                # remove key, it is invalid now\r\n                db(QUERY).update(token=expired)\r\n                token = expired\r\n\r\n    form = SQLFORM(db.trello_auth).process(next=URL(args=[0]))\r\n    #linkList = []\r\n    #for note in notifications:\r\n    #    linkList.append("https://trello.com/c/" + note["data"]["card"]["shortlink"])\r\n    return locals()\r\n    # https://trello.com/c/gjmBBLSs/14-use-as-many-boards-as-you-want-we-ll-make-more\r\n\r\ndef mentortrack():\r\n    """\r\n    currently a testing site for the mentor track form\r\n    """\r\n    tempTable = db(db.mentorTrack_data==db.auth_user.id).select()\r\n    form = SQLFORM(db.mentorTrack_data)\r\n    return locals()\r\n\r\n@auth.requires_login()\r\ndef processinvoices():\r\n    """\r\n    A view to process and export invoices or various clients\r\n    TODO: make it variable per client and per period via inputs of some type #########################################\r\n          have it call the gspread function\r\n          process a log of some sort\r\n          display a processing icon and confirmation message\r\n    """\r\n    \r\n    form=FORM(\'Invoice Details:\',\r\n              INPUT(_name=\'start\', _class=\'date\', requires=IS_NOT_EMPTY()),\r\n              INPUT(_name=\'end\', _class=\'date\', requires=IS_NOT_EMPTY()),\r\n              INPUT(_name=\'project\', requires=IS_NOT_EMPTY()),\r\n              INPUT(_type=\'submit\'))\r\n\r\n    if form.accepts(request,session):\r\n        response.flash = \'form accepted\'\r\n    elif form.errors:\r\n        response.flash = \'form has errors\'\r\n    else:\r\n        response.flash = \'please fill out the form\'\r\n    # Get the vars from the form to process the invoices\r\n    start = form.vars.start\r\n    end = form.vars.end\r\n    project = form.vars.project\r\n    # Initialize various variables to use in the function\r\n    clockSet = None\r\n    empIdList = []\r\n    empInfo = []\r\n    empList = []\r\n    totalHours = 0\r\n    # Initialize a Google Docs client\r\n    gc = gspread.login(\'dawg3tt@gmail.com\', \'mol090901!\')\r\n    # Check to see if the form has been submitted\r\n    # TODO: tie this to the form submission, maybe using onvalidation ###################################################\r\n    if start is not None:\r\n        response.flash = "Processing Invoices for " + project + ", period: " + start + " - " + end\r\n        # Convert form variables to date objects\r\n        start = datetime.strptime(start, "%m/%d/%Y")\r\n        end = datetime.strptime(end, "%m/%d/%Y")\r\n        # Query and select records from the database that match the form variables\r\n        query = (db.timeclock.work_date >= start) & (db.timeclock.work_date <= end) & (db.timeclock.project == project)\r\n        clockEntries = db(query).select(db.timeclock.ALL, orderby=~db.timeclock.work_date)\r\n        # Get a list of unique employee ids from the time submissions\r\n        for item in clockEntries:\r\n            empIdList.append(item.usr_id)\r\n        empIdList = set(empIdList)\r\n        # Build a list of Employee object instances\r\n        for id in empIdList:\r\n            empInfo = db(db.auth_user.id == id).select().first()\r\n            # Instantiate an Employee object, initialize an empty array for timeclock entries and a variable to hold the total hours\r\n            emp = Employee(id, empInfo.first_name, empInfo.last_name, empInfo.email)\r\n            emp.entries = []\r\n            emp.totalHours = 0\r\n            emp.project = project\r\n            # Add the timeclock entries for this employee to the empty array and calculate the total hours\r\n            for entry in clockEntries:\r\n                if entry.usr_id == id:\r\n                    emp.entries.append(entry)\r\n                    emp.totalHours += entry.hours\r\n            # Add the new Employee object to the Employee object list\r\n            empList.append(emp)\r\n\r\n        # For each id create an invoice and format it\r\n        for employee in empList:\r\n            # call functions to create and format invoices\r\n            # TODO: find a way to create new invoices programmatically ##################################################\r\n            createInvoices(employee, gc, start, end)\r\n            # formatIncoices()\r\n    \r\n        clockEntries = []\r\n        entryRange = []\r\n\r\n\r\n    return dict(form=form, clockEntries=clockEntries, empList=empList, empInfo=empInfo)\r\n\r\ndef createInvoices(employee, gc, start, end):\r\n    """\r\n    A function to create a Google doc with an invoice or each employee\r\n    """\r\n    response.flash = "Creating Invoices"\r\n    ss = gc.open("web2py_tester")\r\n    wks = ss.sheet1\r\n    newks = ss.add_worksheet(title=employee.firstName + " " + employee.lastName, rows="70", cols="5")\r\n    headerRange = newks.range(\'A1:E15\')\r\n    entryRange = newks.range(\'A16:E\' + str(len(employee.entries) + 15))\r\n    for cell in headerRange:\r\n        cell.value = \'\'\r\n    headerRange[0].value = "Invoice"\r\n    headerRange[10].value = "From:"\r\n    headerRange[11].value = employee.firstName + " " + employee.lastName\r\n    headerRange[13].value = "Period"\r\n    headerRange[18].value = "From:"\r\n    headerRange[19].value = "To:"\r\n    headerRange[23].value = start\r\n    headerRange[24].value = end\r\n    headerRange[40].value = "To:"\r\n    headerRange[41].value = "Deseret Digital Media"\r\n    headerRange[44].value = "Hours Total"\r\n    headerRange[46].value = "55 North 300 West Ste 500"\r\n    headerRange[49].value = employee.totalHours\r\n    headerRange[51].value = "Salt Lake City, UT 84101"\r\n    headerRange[54].value = "Total"\r\n    headerRange[56].value = "801-333-7400"\r\n    headerRange[59].value = employee.totalHours * 10\r\n    headerRange[70].value = "Date"\r\n    headerRange[71].value = "Description"\r\n    headerRange[72].value = "Hours"\r\n    headerRange[73].value = "Rate"\r\n    headerRange[74].value = "Subtotal"\r\n\r\n    outputEntries = convertGdOutput(employee.entries)\r\n    i = 0\r\n    for cell in entryRange:\r\n        cell.value = outputEntries[i]\r\n        i += 1\r\n\r\n    newks.update_cells(headerRange)\r\n    newks.update_cells(entryRange)\r\n\r\ndef convertGdOutput(entries):\r\n    # convert a set of time entries from the database to a valid Google Docs format\r\n    outputEntries = []\r\n    for entry in entries:\r\n        outputEntries.extend([entry.work_date, entry.description, entry.hours, 10, float(entry.hours) * 10])\r\n    return outputEntries\r\n\r\ndef calcHours(form):\r\n    timeIn = form.vars.time_in\r\n    timeOut = form.vars.time_out\r\n    timeInAmPm = form.vars.time_in_ampm\r\n    timeOutAmPm = form.vars.time_out_ampm\r\n    timeInHour = int(timeIn[0:2])\r\n    timeInMin = int(timeIn[3:5])\r\n    timeOutHour = int(timeOut[0:2])\r\n    timeOutMin = int(timeOut[3:5])\r\n    if timeInAmPm == \'PM\':\r\n        timeInHour += 12\r\n    if timeOutAmPm == \'PM\':\r\n        timeOutHour += 12\r\n    hourDiff = timeOutHour - timeInHour\r\n    minDiff = (timeOutMin - timeInMin)/60.0\r\n    form.vars.hours = "%.2f" % (hourDiff + minDiff)\r\n\r\ndef gdatatest():\r\n    """\r\n    testing integration with Google\r\n    """\r\n    gemail = \'dawg3tt@gmail.com\'\r\n    gpwd = \'mol090901!\'\r\n\r\n    ############ get docs list example #################################################\r\n    # Create a client class which will make HTTP requests with Google Docs server.\r\n    gdataClient = gdata.docs.service.DocsService()\r\n    # Authenticate using your Google Docs email address and password.\r\n    gdataClient.email = gemail\r\n    gdataClient.password = gpwd\r\n    gdataClient.source = \'SIRI Admin\'\r\n    gdataClient.ProgrammaticLogin()\r\n    # Query the server for an Atom feed containing a list of your documents.\r\n    docsFeed = gdataClient.GetDocumentListFeed()\r\n    ####################################################################################\r\n    \r\n    return dict(docsFeed=docsFeed)\r\n\r\ndef gspreadtest():\r\n    clockEntries = db(db.timeclock.project == \'DDM\').select(db.timeclock.ALL, orderby=~db.timeclock.usr_id)\r\n\r\n    gc = gspread.login(\'dawg3tt@gmail.com\', \'mol090901!\')\r\n    ss = gc.open("web2py_tester")\r\n    wks = ss.sheet1\r\n    timeList = wks.range(\'A16:E30\')\r\n    for cell in timeList:\r\n        cell.value = \'\'\r\n    # wks.update_cells(timeList)\r\n    newks = ss.add_worksheet(title=\'clockEntries[0].usr_id\', rows="70", cols="5")\r\n    newks.update_cell(1,1, \'Invoice\')\r\n    copyRange = wks.range(\'A1:F30\')\r\n    headerRange = newks.range(\'A1:F30\')\r\n    # for cell in headerRange:\r\n    #     cell.value = copyRange.value\r\n    copyList = wks.get_all_values()\r\n    newks.update_cells(copyRange)\r\n\r\n    update = False\r\n    if update:\r\n        rate = 10\r\n        idx = 16\r\n        for entry in clockEntries:\r\n            wks.update_cell(idx, 1, entry.work_date)\r\n            wks.update_cell(idx, 2, entry.description)\r\n            wks.update_cell(idx, 3, entry.hours)\r\n            wks.update_cell(idx, 4, rate) #TODO: this should be replaced by a query for rate added by admin ################\r\n            wks.update_cell(idx, 5, rate*entry.hours)\r\n            idx += 1\r\n\r\n    return dict(\r\n        timeList=timeList, \r\n        clockEntries=clockEntries, \r\n        wks=wks,\r\n        newks=newks,\r\n        copyRange=copyRange, \r\n        copyList=copyList\r\n        )\r\n\r\n# def copyCells(values, newks):\r\n#     for row in values:\r\n#         for cell in rows:\r\n\nresponse._vars=response._caller(mentortrack)\n'
p7
sS'snapshot'
p8
(dp9
sS'traceback'
p10
S'Traceback (most recent call last):\n  File "/Users/adin/Work/SIRI/TimeClock/siri/gluon/restricted.py", line 212, in restricted\n    exec ccode in environment\n  File "/Users/adin/Work/SIRI/TimeClock/siri/applications/siriadmin/controllers/timeclock.py", line 388, in <module>\n  File "/Users/adin/Work/SIRI/TimeClock/siri/gluon/globals.py", line 194, in <lambda>\n    self._caller = lambda f: f()\n  File "/Users/adin/Work/SIRI/TimeClock/siri/applications/siriadmin/controllers/timeclock.py", line 174, in mentortrack\n    tempTable = db(db.mentorTrack_data==db.auth_user.id).select()\n  File "/Users/adin/Work/SIRI/TimeClock/siri/gluon/dal.py", line 9958, in select\n    return adapter.select(self.query,fields,attributes)\n  File "/Users/adin/Work/SIRI/TimeClock/siri/gluon/dal.py", line 2245, in select\n    return super(SQLiteAdapter, self).select(query, fields, attributes)\n  File "/Users/adin/Work/SIRI/TimeClock/siri/gluon/dal.py", line 1691, in select\n    sql = self._select(query, fields, attributes)\n  File "/Users/adin/Work/SIRI/TimeClock/siri/gluon/dal.py", line 1601, in _select\n    sql_w = \' WHERE \' + self.expand(query) if query else \'\'\n  File "/Users/adin/Work/SIRI/TimeClock/siri/gluon/dal.py", line 1366, in expand\n    return op(first, second, **optional_args)\n  File "/Users/adin/Work/SIRI/TimeClock/siri/gluon/dal.py", line 1276, in EQ\n    self.expand(second, first.type))\n  File "/Users/adin/Work/SIRI/TimeClock/siri/gluon/dal.py", line 1376, in expand\n    return str(self.represent(expression,field_type))\n  File "/Users/adin/Work/SIRI/TimeClock/siri/gluon/dal.py", line 1822, in represent\n    return str(long(obj))\nTypeError: long() argument must be a string or a number, not \'Table\'\n'
p11
s.